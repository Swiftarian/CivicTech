import re
from PIL import Image, ImageOps
import pytesseract

# ==========================================
# 1. é é¢è­˜åˆ¥é‚è¼¯
# ==========================================

def identify_page_type(header_text):
    """
    æ ¹æ“šé é¢å‰ 30 å€‹å­—è­˜åˆ¥æ–‡ä»¶é¡å‹
    """
    if not header_text:
        return "æœªçŸ¥é é¢"
    
    text = header_text.replace(" ", "").replace("\n", "")
    
    # é—œéµå­—å°æ‡‰è¡¨
    keywords = {
        "ç›®éŒ„": "ç›®éŒ„",
        "æª¢ä¿®ç”³å ±è¡¨": "æ¶ˆé˜²å®‰å…¨è¨­å‚™æª¢ä¿®ç”³å ±è¡¨",
        "æª¢ä¿®å ±å‘Šæ›¸": "æ¶ˆé˜²å®‰å…¨è¨­å‚™æª¢ä¿®å ±å‘Šæ›¸",
        "æ”¹å–„è¨ˆç•«æ›¸": "æ¶ˆé˜²å®‰å…¨è¨­å‚™æ”¹å–„è¨ˆç•«æ›¸",
        "ç¨®é¡åŠæ•¸é‡è¡¨": "æ¶ˆé˜²å®‰å…¨è¨­å‚™ç¨®é¡åŠæ•¸é‡è¡¨",
        "æ»…ç«å™¨": "æ»…ç«å™¨æª¢æŸ¥è¡¨",
        "å®¤å…§æ¶ˆé˜²æ “": "å®¤å…§æ¶ˆé˜²æ “è¨­å‚™æª¢æŸ¥è¡¨",
        "è‡ªå‹•æ’’æ°´": "è‡ªå‹•æ’’æ°´è¨­å‚™æª¢æŸ¥è¡¨",
        "æ³¡æ²«": "æ³¡æ²«æ»…ç«è¨­å‚™æª¢æŸ¥è¡¨",
        "ç«è­¦è‡ªå‹•è­¦å ±": "ç«è­¦è‡ªå‹•è­¦å ±è¨­å‚™æª¢æŸ¥è¡¨",
        "ç·Šæ€¥å»£æ’­": "ç·Šæ€¥å»£æ’­è¨­å‚™æª¢æŸ¥è¡¨",
        "æ¨™ç¤ºè¨­å‚™": "æ¨™ç¤ºè¨­å‚™æª¢æŸ¥è¡¨",
        "é¿é›£è¨­å‚™": "é¿é›£è¨­å‚™æª¢æŸ¥è¡¨",
        "ç·Šæ€¥ç…§æ˜": "ç·Šæ€¥ç…§æ˜è¨­å‚™æª¢æŸ¥è¡¨",
        "é€£çµé€æ°´ç®¡": "é€£çµé€æ°´ç®¡æª¢æŸ¥è¡¨",
        "æ’ç…™": "æ’ç…™è¨­å‚™æª¢æŸ¥è¡¨",
        "ç„¡ç·šé›»": "ç„¡ç·šé›»é€šä¿¡è¼”åŠ©è¨­å‚™æª¢æŸ¥è¡¨",
        "ä½¿ç”¨åŸ·ç…§": "å»ºç¯‰ç‰©ä½¿ç”¨åŸ·ç…§å½±æœ¬",
        "ç‡Ÿåˆ©äº‹æ¥­": "ç‡Ÿåˆ©äº‹æ¥­ç™»è¨˜è­‰å½±æœ¬",
        "é–‹æ¥­è­‰æ›¸": "å°ˆæ¥­æ©Ÿæ§‹åˆæ ¼è­‰æ›¸å½±æœ¬",
        "è¨­å‚™å¸«": "æ¶ˆé˜²è¨­å‚™å¸«(å£«)è­‰æ›¸å½±æœ¬",
        "èº«åˆ†è­‰": "ç®¡ç†æ¬Šäººèº«åˆ†è­‰å½±æœ¬"
    }
    
    for key, value in keywords.items():
        if key in text:
            return value
            
    return "å…¶ä»–æ–‡ä»¶"

# ==========================================
# 2. Checkbox æª¢æ¸¬é‚è¼¯ (Pixel Analysis)
# ==========================================

def detect_checkbox_state(image, text_box):
    """
    åˆ†ææ–‡å­—å·¦å´å€åŸŸçš„åƒç´ å¯†åº¦ä¾†åˆ¤æ–·æ˜¯å¦æ‰“å‹¾
    
    Args:
        image: åŸå§‹åœ–ç‰‡ (PIL Image)
        text_box: æ–‡å­—å€åŸŸ (left, top, width, height)
    
    Returns:
        bool: True (æœ‰æ‰“å‹¾), False (æœªæ‰“å‹¾)
    """
    left, top, width, height = text_box
    
    # å®šç¾©æª¢æŸ¥å€åŸŸï¼šæ–‡å­—å·¦å´
    # å‡è¨­ checkbox åœ¨æ–‡å­—å·¦é‚Šç´„ 20-50 pixels è™•ï¼Œå¤§å°ç´„ 20x20
    # é€™è£¡éœ€è¦æ ¹æ“šå¯¦éš›åœ–ç‰‡è§£æåº¦èª¿æ•´
    
    # å¯¬é¬†è¨­å®šï¼šå¾€å·¦æŠ“ 50pxï¼Œé«˜åº¦èˆ‡æ–‡å­—ç›¸åŒ
    check_region_width = 50 
    check_region_left = max(0, left - check_region_width)
    
    # è£åˆ‡å‡ºæª¢æŸ¥å€åŸŸ
    region = image.crop((check_region_left, top, left, top + height))
    
    # è½‰ç‚ºç°éšä¸¦äºŒå€¼åŒ–
    gray = region.convert('L')
    # ç°¡å–®äºŒå€¼åŒ–ï¼šä½æ–¼ 128 è¦–ç‚ºé»‘è‰² (ç­†è·¡)
    bw = gray.point(lambda x: 0 if x < 150 else 255, '1')
    
    # è¨ˆç®—é»‘è‰²åƒç´ æ¯”ä¾‹
    # Checkbox å€åŸŸæ‡‰è©²æœƒæœ‰æ–¹æ¡†ç·šæ¢ + æ‰“å‹¾ç·šæ¢
    # ç©ºç™½å€åŸŸå‰‡æ˜¯å…¨ç™½
    
    # å–å¾—åƒç´ æ•¸æ“š
    pixels = list(bw.getdata())
    total_pixels = len(pixels)
    black_pixels = pixels.count(0)
    
    if total_pixels == 0: return False
    
    density = black_pixels / total_pixels
    
    # é–¾å€¼åˆ¤æ–·
    # å¦‚æœæ˜¯å–®ç´”æ–¹æ¡† (â–¡)ï¼Œå¯†åº¦è¼ƒä½
    # å¦‚æœæ˜¯æ‰“å‹¾æ–¹æ¡† (â˜‘)ï¼Œå¯†åº¦è¼ƒé«˜
    # é€™è£¡å¯èƒ½éœ€è¦å¯¦é©—èª¿æ•´é–¾å€¼ã€‚
    # å‡è¨­æ–¹æ¡†ä½” 10%ï¼Œæ‰“å‹¾å¯èƒ½ä½” 20% ä»¥ä¸Š
    
    # ç‚ºäº†æ›´æº–ç¢ºï¼Œæˆ‘å€‘å‡è¨­ "æœ‰å¢¨æ°´" å°±æ˜¯æœ‰æ±è¥¿ã€‚
    # ä½†è¦å€åˆ† "ç©ºæ¡†" å’Œ "æ‰“å‹¾æ¡†" æ¯”è¼ƒé›£å–®ç´”ç”¨å¯†åº¦ã€‚
    # æ›¿ä»£æ–¹æ¡ˆï¼šOCR é›–ç„¶ä¸æº–ï¼Œä½†å¯ä»¥è¼”åŠ©ã€‚
    # æˆ–è€…ï¼šæˆ‘å€‘åªåˆ¤æ–· "æ˜¯å¦æœ‰è¶³å¤ çš„é»‘è‰²åƒç´ " ä»£è¡¨æœ‰æª¢æ ¸é …ç›®ã€‚
    # æ ¹æ“šä½¿ç”¨è€…éœ€æ±‚ "æ–¹æ¡†å…§æœ‰æ‰“å‹¾çš„å°±æ˜¯æœ‰æª¢è¤‡"ï¼Œ
    # æˆ‘å€‘å‡è¨­ "æ‰“å‹¾" æœƒé¡¯è‘—å¢åŠ é»‘è‰²åƒç´ ã€‚
    
    return density > 0.15  # æš«å®šé–¾å€¼ 15%

# ==========================================
# 3. TOC è§£æé‚è¼¯
# ==========================================

def parse_toc_requirements(toc_image, toc_text):
    """
    è§£æç›®éŒ„é ï¼Œæ‰¾å‡ºè¢«æ‰“å‹¾çš„é …ç›®
    """
    required_docs = []
    
    try:
        # ä½¿ç”¨ pytesseract å–å¾—è©³ç´°è³‡æ–™ (åŒ…å«åº§æ¨™)
        # pytesseract.image_to_data å›å‚³ dict
        data = pytesseract.image_to_data(toc_image, lang='chi_tra', output_type=pytesseract.Output.DICT)
    except pytesseract.pytesseract.TesseractNotFoundError:
        # Tesseract æœªå®‰è£æˆ–ä¸åœ¨ PATH
        raise RuntimeError(
            "âŒ Tesseract OCR æœªå®‰è£æˆ–æœªåŠ å…¥ç³»çµ± PATH\n\n"
            "è«‹é¸æ“‡ä»¥ä¸‹ä»»ä¸€è§£æ±ºæ–¹æ¡ˆï¼š\n\n"
            "ã€æ–¹æ¡ˆ 1ã€‘å®‰è£ Tesseract OCR (Windows):\n"
            "  1. ä¸‹è¼‰ï¼šhttps://github.com/UB-Mannheim/tesseract/wiki\n"
            "  2. å®‰è£æ™‚å‹¾é¸ 'Chinese - Traditional' èªè¨€åŒ…\n"
            "  3. å®‰è£å®Œæˆå¾Œé‡æ–°å•Ÿå‹• Streamlit\n\n"
            "ã€æ–¹æ¡ˆ 2ã€‘ä½¿ç”¨ Vision AI (ç„¡éœ€ Tesseract):\n"
            "  1. åœ¨å´é‚Šæ¬„å‹¾é¸ã€ŒğŸ” å•Ÿç”¨ Vision AI æ–‡ä»¶åˆ†æã€\n"
            "  2. ç¢ºä¿ Ollama å·²å•Ÿå‹•ä¸”å®‰è£ llama3.2-vision\n"
            "  3. Vision AI æº–ç¢ºåº¦æ›´é«˜ä¸”ç„¡éœ€é¡å¤–å®‰è£"
        )
    except Exception as e:
        # å…¶ä»– OCR éŒ¯èª¤
        raise RuntimeError(f"OCR è™•ç†å¤±æ•—: {str(e)}\nå»ºè­°ï¼šåˆ‡æ›åˆ° Vision AI æ¨¡å¼ä»¥ç²å¾—æ›´å¥½çš„çµæœ")
    
    
    n_boxes = len(data['text'])
    
    # æ¬²æœå°‹çš„é—œéµå­—æ¸…å–® (å°æ‡‰æ¨™æº–æ–‡ä»¶åç¨±)
    target_docs = [
        "æ¶ˆé˜²å®‰å…¨è¨­å‚™æª¢ä¿®ç”³å ±è¡¨", "æ¶ˆé˜²å®‰å…¨è¨­å‚™æª¢ä¿®å ±å‘Šæ›¸", "æ¶ˆé˜²å®‰å…¨è¨­å‚™æ”¹å–„è¨ˆç•«æ›¸", "æ¶ˆé˜²å®‰å…¨è¨­å‚™ç¨®é¡åŠæ•¸é‡è¡¨",
        "æ»…ç«å™¨æª¢æŸ¥è¡¨", "å®¤å…§æ¶ˆé˜²æ “è¨­å‚™æª¢æŸ¥è¡¨", "è‡ªå‹•æ’’æ°´è¨­å‚™æª¢æŸ¥è¡¨", "æ³¡æ²«æ»…ç«è¨­å‚™æª¢æŸ¥è¡¨", 
        "ç«è­¦è‡ªå‹•è­¦å ±è¨­å‚™æª¢æŸ¥è¡¨", "ç·Šæ€¥å»£æ’­è¨­å‚™æª¢æŸ¥è¡¨", "æ¨™ç¤ºè¨­å‚™æª¢æŸ¥è¡¨", "é¿é›£è¨­å‚™æª¢æŸ¥è¡¨",
        "ç·Šæ€¥ç…§æ˜è¨­å‚™æª¢æŸ¥è¡¨", "é€£çµé€æ°´ç®¡æª¢æŸ¥è¡¨", "æ’ç…™è¨­å‚™æª¢æŸ¥è¡¨", "ç„¡ç·šé›»é€šä¿¡è¼”åŠ©è¨­å‚™æª¢æŸ¥è¡¨",
        "å»ºç¯‰ç‰©ä½¿ç”¨åŸ·ç…§å½±æœ¬", "ç‡Ÿåˆ©äº‹æ¥­ç™»è¨˜è­‰å½±æœ¬", "å°ˆæ¥­æ©Ÿæ§‹åˆæ ¼è­‰æ›¸å½±æœ¬", 
        "æ¶ˆé˜²è¨­å‚™å¸«(å£«)è­‰æ›¸å½±æœ¬", "ç®¡ç†æ¬Šäººèº«åˆ†è­‰å½±æœ¬"
    ]
    
    # ç°¡å–®æ¼”ç®—æ³•ï¼š
    # 1. éæ­· OCR çµæœï¼Œæ‰¾åˆ°åŒ…å«é—œéµå­—çš„è¡Œ
    # 2. å–å¾—è©²è¡Œçš„ bounding box
    # 3. å‘¼å« detect_checkbox_state åˆ¤æ–·å·¦å´æ˜¯å¦æ‰“å‹¾
    
    # ç‚ºäº†é¿å…é‡è¤‡è™•ç†åŒä¸€è¡Œ (å› ç‚º image_to_data æ˜¯æ¯å€‹å­—åˆ†é–‹çš„)ï¼Œæˆ‘å€‘éœ€è¦åˆ†çµ„
    # é€™è£¡ç°¡åŒ–è™•ç†ï¼šå¦‚æœåµæ¸¬åˆ°é—œéµå­—ï¼Œå°±æª¢æŸ¥è©²å­—å·¦å´
    # ä½†é€™æ¨£ä¸æº–ï¼Œå› ç‚º checkbox åœ¨æ•´è¡Œæ–‡å­—çš„æœ€å·¦é‚Šã€‚
    
    # æ”¹é€²ï¼šå…ˆå°‡æ–‡å­—é‡çµ„ç‚ºè¡Œï¼Œä¸¦è¨ˆç®—æ•´è¡Œçš„ bbox
    lines = {} # block_num + par_num + line_num -> {text: [], left: min, top: min, width: sum, height: max}
    
    for i in range(n_boxes):
        if int(data['conf'][i]) > 0: # éæ¿¾æ‰ä¿¡å¿ƒåº¦éä½çš„
            key = (data['block_num'][i], data['par_num'][i], data['line_num'][i])
            if key not in lines:
                lines[key] = {
                    'text': [], 
                    'left': data['left'][i], 
                    'top': data['top'][i], 
                    'right': data['left'][i] + data['width'][i],
                    'bottom': data['top'][i] + data['height'][i]
                }
            else:
                l = lines[key]
                l['text'].append(data['text'][i])
                l['left'] = min(l['left'], data['left'][i])
                l['top'] = min(l['top'], data['top'][i])
                l['right'] = max(l['right'], data['left'][i] + data['width'][i])
                l['bottom'] = max(l['bottom'], data['top'][i] + data['height'][i])
    
    # åˆ†ææ¯ä¸€è¡Œ
    for key, line_data in lines.items():
        line_text = "".join(line_data['text'])
        
        # æ¯”å°é—œéµå­—
        matched_doc = None
        for doc in target_docs:
            # æ¨¡ç³Šæ¯”å°ï¼šåªè¦åŒ…å«éƒ¨åˆ†é—œéµå­—
            # ä¾‹å¦‚ "æ»…ç«å™¨æª¢æŸ¥è¡¨" å¯èƒ½ OCR æˆ "æ»…ç«å™¨æª¢è¡¨"
            # å–æ ¸å¿ƒé—œéµå­—
            core_key = doc[:4] # å–å‰4å­—
            if core_key in line_text:
                matched_doc = doc
                break
        
        if matched_doc:
            # æª¢æŸ¥ Checkbox
            bbox = (line_data['left'], line_data['top'], line_data['right'] - line_data['left'], line_data['bottom'] - line_data['top'])
            is_checked = detect_checkbox_state(toc_image, bbox)
            
            if is_checked:
                required_docs.append(matched_doc)
                
    return required_docs

